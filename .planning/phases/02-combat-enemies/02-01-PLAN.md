---
phase: 02-combat-enemies
plan: 01
type: execute
---

<objective>
Implement core combat system with stats, damage calculation, and health tracking.

Purpose: Establish the combat math foundation that both player and enemies will use. Simple, predictable formulas enable tactical planning.
Output: CombatStats component, damage calculation function, health tracking system integrated with Player entity.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-combat-enemies/02-RESEARCH.md
@.planning/phases/01-foundation-core-loop/01-03-SUMMARY.md

**Tech stack available:**
- Phaser 3 (3.90.0+) - Game framework
- Rot.js (0.5.0+) - Roguelike toolkit
- TypeScript (5.x) - Type safety
- GridManager utility for coordinate conversion

**Established patterns:**
- Grid-based entities with separate grid position and sprite position
- Entity interface with gridX, gridY properties
- Simple update loop in GameScene

**Research guidance (from 02-RESEARCH.md):**
- Use simple damage formula: `Random(1 to (attack - defense))`
- Don't overcomplicate early - clear combat math for tactical planning
- Separate combat logic from rendering (no Phaser dependencies in combat functions)
- Start with 4 core stats: maxHP, currentHP, attack, defense
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CombatStats component and damage calculation</name>
  <files>src/types/index.ts, src/systems/CombatSystem.ts</files>
  <action>
    In src/types/index.ts:
    - Add CombatStats interface with: maxHP: number, currentHP: number, attack: number, defense: number
    - Add CombatEntity interface extending Entity with: stats: CombatStats, isAlive(): boolean, takeDamage(amount: number): void

    In src/systems/CombatSystem.ts:
    - Create CombatSystem class with static methods (no state, pure functions)
    - calculateDamage(attacker: CombatStats, defender: CombatStats): number
      - Formula: const baseDamage = attacker.attack - defender.defense
      - If baseDamage <= 0, return 0
      - Return Math.floor(Math.random() * baseDamage) + 1 (damage from 1 to baseDamage)
    - applyDamage(target: CombatEntity, damage: number): void
      - target.stats.currentHP = Math.max(0, target.stats.currentHP - damage)

    IMPORTANT: Keep combat logic separate from Phaser. No sprite manipulation in CombatSystem. Follow research pattern of "simple transparent math" for tactical planning.
  </action>
  <verify>TypeScript compiles without errors, CombatSystem exports correctly</verify>
  <done>CombatStats interface defined, calculateDamage returns predictable results (0 if defense >= attack, 1 to (attack-defense) otherwise), applyDamage reduces currentHP correctly</done>
</task>

<task type="auto">
  <name>Task 2: Add combat stats to Player entity</name>
  <files>src/entities/Player.ts, src/scenes/GameScene.ts</files>
  <action>
    In src/entities/Player.ts:
    - Update Player class to implement CombatEntity interface (from types)
    - Add stats property: CombatStats = { maxHP: 20, currentHP: 20, attack: 5, defense: 2 }
    - Add isAlive(): boolean method that returns this.stats.currentHP > 0
    - Add takeDamage(amount: number): void method
      - Import CombatSystem
      - Call CombatSystem.applyDamage(this, amount)
      - If !this.isAlive(), destroy sprite (this.sprite.destroy())
    - Add attack(target: CombatEntity): void method
      - const damage = CombatSystem.calculateDamage(this.stats, target.stats)
      - target.takeDamage(damage)
      - Return damage for future combat log

    In src/scenes/GameScene.ts:
    - No changes needed yet (Player already creates and updates in scene)
    - Player now has combat capability ready for enemies

    AVOID: Don't add UI for health bars yet (defer to later). Don't change existing movement logic. Just add combat capability to Player class following the CombatEntity interface.
  </action>
  <verify>TypeScript compiles, Player has stats property, isAlive/takeDamage/attack methods exist</verify>
  <done>Player entity implements CombatEntity interface with starting stats (20 HP, 5 attack, 2 defense), combat methods functional, player sprite destroys when HP reaches 0</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] TypeScript compiles without errors
- [ ] CombatStats and CombatEntity interfaces exported from types/index.ts
- [ ] CombatSystem has calculateDamage and applyDamage static methods
- [ ] Player implements CombatEntity interface with working combat methods
- [ ] Damage calculation follows research formula (attack - defense + random variance)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Combat math is simple and predictable (per research guidance)
- Player entity has combat capability
- Foundation ready for enemy entities to use same system

</success_criteria>

<output>
After completion, create `.planning/phases/02-combat-enemies/02-01-SUMMARY.md`:

# Phase 2 Plan 1: Combat System & Damage Summary

**Combat foundation established with stats, damage calculation, and health tracking**

## Accomplishments

- CombatStats interface created for all combatants
- CombatSystem utility with simple damage formulas
- Player entity implements combat capability (attack, take damage, health tracking)
- Damage calculation: predictable (attack - defense) with small random variance

## Files Created/Modified

- `src/types/index.ts` - CombatStats and CombatEntity interfaces
- `src/systems/CombatSystem.ts` - Combat logic (damage calculation, health management)
- `src/entities/Player.ts` - Combat methods added to Player class

## Decisions Made

- Used simple damage formula per research (attack - defense + variance)
- Player starts with 20 HP, 5 attack, 2 defense (baseline for balancing enemies)
- Separated combat logic from rendering (CombatSystem is Phaser-independent)

## Issues Encountered

[Document any issues, or state "None"]

## Next Step

Ready for 02-02-PLAN.md - Enemy Entities & AI
</output>
