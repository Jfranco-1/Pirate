---
phase: 02-combat-enemies
plan: 02
type: execute
---

<objective>
Create enemy entities with distinct AI behaviors for tactical variety.

Purpose: Add 3 enemy types with different behaviors (aggressive melee, ranged, defensive) to create tactical challenges. Behavior variety, not stat bloat, makes enemies interesting.
Output: Base Enemy class and 3 specific enemy types (Goblin, Archer, Brute) with AI using Rot.js pathfinding.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-combat-enemies/02-RESEARCH.md
@.planning/phases/02-combat-enemies/02-01-SUMMARY.md

**From Plan 02-01:**
- CombatStats interface available (maxHP, currentHP, attack, defense)
- CombatEntity interface (stats, isAlive, takeDamage methods)
- CombatSystem utility with calculateDamage and applyDamage
- Player has combat capability

**Research guidance:**
- Enemy variety through BEHAVIOR not stats (aggressive vs ranged vs defensive)
- Use Rot.js A* pathfinding for enemy movement (don't hand-roll)
- Simple AI patterns: AGGRESSIVE (chase player), RANGED (maintain 3-5 tiles), DEFENSIVE (only attack when adjacent)
- Enemies should be weaker than player individually (player is outnumbered)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create base Enemy class with behavior system</name>
  <files>src/entities/Enemy.ts, src/types/index.ts</files>
  <action>
    In src/types/index.ts:
    - Add AIBehavior enum with: AGGRESSIVE, RANGED, DEFENSIVE

    In src/entities/Enemy.ts:
    - Create Enemy class implementing CombatEntity interface
    - Constructor(scene: Phaser.Scene, gridX: number, gridY: number, stats: CombatStats, behavior: AIBehavior, color: number)
    - Properties: gridX, gridY, stats, behavior, sprite (Phaser.GameObjects.Sprite), scene
    - Create sprite with color tint (this.sprite = scene.add.sprite(0, 0, '').setTint(color).setDisplaySize(28, 28))
    - Implement isAlive(): boolean - returns this.stats.currentHP > 0
    - Implement takeDamage(amount: number): void
      - CombatSystem.applyDamage(this, amount)
      - If !this.isAlive(), destroy sprite
    - Add attack(target: CombatEntity): void
      - const damage = CombatSystem.calculateDamage(this.stats, target.stats)
      - target.takeDamage(damage)
    - Add moveTo(gridX: number, gridY: number): void
      - Updates this.gridX, this.gridY
      - Call updateSpritePosition(gridManager) to sync sprite
    - Add updateSpritePosition(gridManager: GridManager): void
      - Convert grid position to pixels
      - Set sprite position
    - Add selectAction(player: Player, map: number[][]): void (AI decision-making)
      - Placeholder for now, will implement in Task 2

    IMPORTANT: Follow Phase 1 pattern - separate grid position from sprite position. Enemy uses same CombatEntity interface as Player for symmetry.
  </action>
  <verify>TypeScript compiles, Enemy class exports correctly, implements CombatEntity</verify>
  <done>Base Enemy class created with combat methods, behavior property, sprite rendering, placeholder AI method</done>
</task>

<task type="auto">
  <name>Task 2: Implement AI decision-making with Rot.js pathfinding</name>
  <files>src/systems/AISystem.ts, src/entities/Enemy.ts</files>
  <action>
    In src/systems/AISystem.ts:
    - Create AISystem class with static methods
    - Import ROT from 'rot-js' (already in package.json)
    - selectAction(enemy: Enemy, player: Player, map: number[][]): void
      - Switch on enemy.behavior:

        Case AGGRESSIVE:
        - Use Rot.js A* to find path to player
        - const astar = new ROT.Path.AStar(player.gridX, player.gridY, (x, y) => map[y][x] === 0)
        - Build path array, compute from enemy position
        - If path exists and length > 1, move toward player (path[1])
        - If adjacent to player, attack player

        Case RANGED:
        - Calculate distance to player: Math.abs(enemy.gridX - player.gridX) + Math.abs(enemy.gridY - player.gridY)
        - If distance < 3: move away from player (pathfind away)
        - If distance > 5: move toward player (pathfind toward)
        - If 3 <= distance <= 5: attack player (good range)

        Case DEFENSIVE:
        - Calculate if adjacent: distance === 1
        - If adjacent: attack player
        - Otherwise: stay still (don't move)

    In src/entities/Enemy.ts:
    - Update selectAction method to call AISystem.selectAction(this, player, map)

    AVOID: Don't run pathfinding every frame. This is called once per enemy turn. Don't hand-roll pathfinding - use Rot.js as per research "don't hand-roll" list.
  </action>
  <verify>TypeScript compiles, AISystem exports correctly, Rot.js pathfinding imports work</verify>
  <done>AI system implements 3 behavior patterns using Rot.js pathfinding, enemies can decide to move or attack based on behavior</done>
</task>

<task type="auto">
  <name>Task 3: Create 3 specific enemy types</name>
  <files>src/entities/enemies/Goblin.ts, src/entities/enemies/Archer.ts, src/entities/enemies/Brute.ts</files>
  <action>
    Create three enemy types with distinct stats and behaviors:

    In src/entities/enemies/Goblin.ts:
    - Export class Goblin extends Enemy
    - Constructor(scene: Phaser.Scene, gridX: number, gridY: number)
    - Call super with: stats { maxHP: 8, currentHP: 8, attack: 3, defense: 0 }, behavior: AIBehavior.AGGRESSIVE, color: 0xff0000 (red)
    - Goblins are weak, fast, aggressive melee

    In src/entities/enemies/Archer.ts:
    - Export class Archer extends Enemy
    - Constructor(scene: Phaser.Scene, gridX: number, gridY: number)
    - Call super with: stats { maxHP: 6, currentHP: 6, attack: 4, defense: 0 }, behavior: AIBehavior.RANGED, color: 0xffff00 (yellow)
    - Archers are fragile, ranged attackers

    In src/entities/enemies/Brute.ts:
    - Export class Brute extends Enemy
    - Constructor(scene: Phaser.Scene, gridX: number, gridY: number)
    - Call super with: stats { maxHP: 15, currentHP: 15, attack: 6, defense: 3 }, behavior: AIBehavior.DEFENSIVE, color: 0x0000ff (blue)
    - Brutes are tanky, defensive, only attack when engaged

    IMPORTANT: Enemy stats are weaker than player (Player has 20 HP, 5 attack). Player should be able to handle 2-3 enemies. Balance note: Goblin dies in 2 hits, Archer in 1-2 hits, Brute in 3-4 hits.
  </action>
  <verify>TypeScript compiles, three enemy classes export correctly</verify>
  <done>Three enemy types created (Goblin, Archer, Brute) with distinct stats and behaviors, each extending base Enemy class</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] TypeScript compiles without errors
- [ ] AIBehavior enum exists with 3 values
- [ ] Enemy base class implements CombatEntity interface
- [ ] AISystem uses Rot.js A* for pathfinding (not custom pathfinding)
- [ ] Three enemy types (Goblin, Archer, Brute) have distinct behaviors and stats
- [ ] Enemy stats are balanced relative to player (weaker individually)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Enemy variety through behavior, not stat inflation
- Rot.js pathfinding used (per "don't hand-roll" research)
- Three enemy types ready for turn-based combat
- Foundation ready for turn management integration

</success_criteria>

<output>
After completion, create `.planning/phases/02-combat-enemies/02-02-SUMMARY.md`:

# Phase 2 Plan 2: Enemy Entities & AI Summary

**Three enemy types with behavior-driven AI using Rot.js pathfinding**

## Accomplishments

- Base Enemy class with combat capability
- AISystem with 3 behavior patterns (AGGRESSIVE, RANGED, DEFENSIVE)
- Rot.js A* pathfinding integrated for enemy movement
- Three enemy types: Goblin (aggressive), Archer (ranged), Brute (defensive)
- Enemies balanced relative to player (weaker individually)

## Files Created/Modified

- `src/types/index.ts` - AIBehavior enum
- `src/entities/Enemy.ts` - Base enemy class
- `src/systems/AISystem.ts` - AI decision-making with Rot.js pathfinding
- `src/entities/enemies/Goblin.ts` - Aggressive melee enemy
- `src/entities/enemies/Archer.ts` - Ranged enemy (maintains distance)
- `src/entities/enemies/Brute.ts` - Defensive tank enemy

## Decisions Made

- Enemy stats weaker than player (player should handle 2-3 enemies)
- Color-coded sprites: Goblin (red), Archer (yellow), Brute (blue)
- Used Rot.js A* pathfinding per research (don't hand-roll)
- Variety through behavior patterns, not stat complexity

## Issues Encountered

[Document any issues, or state "None"]

## Next Step

Ready for 02-03-PLAN.md - Turn Management & Combat Flow
</output>
