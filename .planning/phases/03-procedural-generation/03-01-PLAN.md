---
phase: 03-procedural-generation
plan: 01
type: execute
---

<objective>
Create room metadata system to tag generated rooms with type, theme, and difficulty.

Purpose: Establishes foundation for smart entity spawning, special room placement, and themed areas. Without metadata, rooms are indistinguishable - can't place boss at furthest point or spawn appropriate enemies per room difficulty.

Output: Type definitions, DungeonGenerator wrapper class extracting room data from Rot.js Digger, integration into GameScene with room metadata available for spawning logic.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-procedural-generation/03-RESEARCH.md
@src/types/index.ts
@src/scenes/GameScene.ts
@src/systems/GridManager.ts

**Current implementation:** Uses `ROT.Map.Digger(25, 18)` in GameScene.ts lines 74-80. Generates dungeon but doesn't track room data - no way to distinguish rooms or place special encounters intelligently.

**From RESEARCH.md:**
- Rot.js Digger provides `getRooms()` method returning room bounds
- Need RoomType enum (START, NORMAL, BOSS, TREASURE, CHALLENGE)
- Need RoomTheme enum (DUNGEON, CAVE, CRYPT, LIBRARY) for future themed areas
- DungeonGenerator pattern: wrap Digger, extract rooms, add metadata
- Don't hand-roll: Use Rot.js for generation, focus on metadata layer

**Tech stack available:** Phaser 3, Rot.js 2.2.1, TypeScript, existing GridManager
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add room metadata types to types/index.ts</name>
  <files>src/types/index.ts</files>
  <action>Add at end of file: RoomType enum (START, NORMAL, BOSS, TREASURE, CHALLENGE), RoomTheme enum (DUNGEON, CAVE, CRYPT, LIBRARY), RoomData interface with fields: x, y, width, height, type (RoomType), theme (RoomTheme), difficulty (number 1-5), connections (number[] for room indices). Follow existing enum pattern in file (export enum with numbered values).</action>
  <verify>TypeScript compiles without errors: npm run dev (check Vite output)</verify>
  <done>RoomType enum with 5 values, RoomTheme enum with 4 values, RoomData interface with 8 fields, no TypeScript errors</done>
</task>

<task type="auto">
  <name>Task 2: Create DungeonGenerator wrapper class</name>
  <files>src/systems/DungeonGenerator.ts</files>
  <action>Create class with generate(width, height) method. Use ROT.Map.Digger internally with default options. Call digger.create() callback to build map array. After creation, call digger.getRooms() to extract room bounds. Convert ROT room objects to RoomData array: map room.getLeft/Right/Top/Bottom to x/y/width/height, assign type (index 0 = START, rest = NORMAL for now), assign random theme from RoomTheme enum, calculate difficulty as Math.min(5, Math.floor(index * 0.5) + 1) for progressive difficulty, initialize empty connections array. Return { map: number[][], rooms: RoomData[] }. Don't use ROT.Map.Cellular or custom algorithms - stick with Digger as research shows it's balanced for room+corridor style.</action>
  <verify>TypeScript compiles, class exports generate method with correct return type</verify>
  <done>DungeonGenerator.ts created, generate() returns map and rooms array, rooms have metadata assigned, compiles without errors</done>
</task>

<task type="auto">
  <name>Task 3: Integrate DungeonGenerator into GameScene</name>
  <files>src/scenes/GameScene.ts</files>
  <action>Import DungeonGenerator at top. Replace lines 73-80 (current ROT.Map.Digger usage) with: const dungeonGen = new DungeonGenerator(); const { map, rooms } = dungeonGen.generate(25, 18); this.map = map; Store rooms in new private property: private rooms: RoomData[] = []; this.rooms = rooms; Add console.log after generation showing room count and types for verification. Keep all existing spawn logic (player, enemies, items) unchanged for now - they'll use room data in later plans. Don't modify renderMap(), player positioning, or spawn logic yet.</action>
  <verify>npm run dev compiles, game runs, console shows "Generated X rooms" message, dungeon renders identically to before, player/enemies/items spawn correctly</verify>
  <done>GameScene uses DungeonGenerator, rooms data stored in this.rooms, game functionality unchanged, TypeScript compiles, dev server runs</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] TypeScript compiles without errors (npm run dev output clean)
- [ ] Game loads and renders dungeon (visit http://localhost:5173/)
- [ ] Console shows room count message
- [ ] Player, enemies, and items spawn correctly
- [ ] Gameplay unchanged from before (movement, combat, items work)
</verification>

<success_criteria>
- All 3 tasks completed
- RoomType and RoomTheme enums defined in types/index.ts
- RoomData interface defined with 8 fields
- DungeonGenerator.ts created and functional
- GameScene.ts integrated with DungeonGenerator
- Room metadata available in this.rooms array
- No TypeScript errors
- Game runs identically to before (foundation for next plans)
</success_criteria>

<output>
After completion, create `.planning/phases/03-procedural-generation/03-01-SUMMARY.md`:

# Phase 3 Plan 1: Room Metadata System Summary

**Established metadata foundation for procedural dungeon enhancements**

## Accomplishments

- Created room type system (START, NORMAL, BOSS, TREASURE, CHALLENGE)
- Created room theme system (DUNGEON, CAVE, CRYPT, LIBRARY)
- Implemented DungeonGenerator wrapper extracting room data from Rot.js
- Integrated into GameScene with room metadata tracking

## Files Created/Modified

- `src/types/index.ts` - Added RoomType, RoomTheme enums and RoomData interface
- `src/systems/DungeonGenerator.ts` - Created wrapper class for metadata extraction
- `src/scenes/GameScene.ts` - Integrated DungeonGenerator, stores room data

## Decisions Made

- Progressive difficulty formula: Math.min(5, Math.floor(index * 0.5) + 1)
- All rooms start as NORMAL type (special assignment in 03-03)
- Random theme assignment (themed zones deferred to future enhancement)

## Issues Encountered

[Document any issues or "None"]

## Next Step

Ready for 03-02-PLAN.md (Connectivity Validation)
</output>
