---
phase: 01-foundation-core-loop
plan: 03
type: execute
---

<objective>
Implement player entity with grid-based movement and keyboard input system, completing the basic turn-based movement loop.

Purpose: Create the core player interaction - moving through the dungeon with keyboard input, respecting grid constraints and wall collisions.
Output: Playable game where player can move through dungeon using arrow keys or WASD, with movement constrained to valid floor tiles.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-core-loop/01-RESEARCH.md
@.planning/phases/01-foundation-core-loop/01-01-SUMMARY.md
@.planning/phases/01-foundation-core-loop/01-02-SUMMARY.md

**Research patterns:**
- Pattern 2 (Grid-Based Movement): Separate entity grid position from sprite pixel position
- Store game state (position, stats) separately from Phaser display objects
- Simple turn-based logic first, don't over-engineer with complex action queues

**Key files from previous plans:**
- src/systems/GridManager.ts - Coordinate conversion utility
- src/types/index.ts - GridPosition type
- src/scenes/GameScene.ts - Has map data and rendering

**Research guidance:**
- Player entity should track grid position (GridPosition type)
- Sprite position calculated from grid position via GridManager
- Movement validates against map array (can't walk through walls)
- Start with simple direct input → move logic (no action queue yet)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Player entity with grid-based position</name>
  <files>src/entities/Player.ts, src/types/index.ts</files>
  <action>
    Create Player class following research Pattern 2 example:

    In src/types/index.ts:
    - Add Entity interface with gridX: number, gridY: number properties

    In src/entities/Player.ts:
    - Create Player class implementing Entity interface
    - Private properties:
      - gridX: number (current grid X position)
      - gridY: number (current grid Y position)
      - sprite: Phaser.GameObjects.Sprite (visual representation)
      - scene: Phaser.Scene (reference to scene)
    - constructor(scene: Phaser.Scene, gridX: number, gridY: number)
      - Store scene reference
      - Set initial grid position
      - Create sprite: this.sprite = scene.add.sprite(0, 0, null) - no texture yet, use placeholder
      - Set sprite color: sprite.setTint(0x00ff00) for visibility (green)
      - Set sprite size: sprite.setDisplaySize(28, 28) - slightly smaller than tile for visual clarity
      - Update sprite pixel position based on grid position
    - move(dx: number, dy: number, map: number[][]): boolean
      - Calculate new position: newX = this.gridX + dx, newY = this.gridY + dy
      - Validate: check array bounds and map[newY][newX] === 0 (walkable floor)
      - If valid: update gridX/gridY, update sprite pixel position, return true
      - If invalid: return false (movement blocked)
    - getGridPosition(): GridPosition
      - Return { x: this.gridX, y: this.gridY }
    - updateSpritePosition(gridManager: GridManager)
      - Convert grid position to pixels via gridManager.gridToPixel()
      - Set sprite.x and sprite.y to pixel position (centered on tile)

    IMPORTANT: Separate grid position (game logic) from sprite position (rendering) as emphasized in research anti-patterns.
  </action>
  <verify>TypeScript compiles, Player class exports correctly, Entity interface defined</verify>
  <done>Player entity created with grid-based movement logic, sprite rendering, collision detection against map</done>
</task>

<task type="auto">
  <name>Task 2: Implement keyboard input for grid-based movement</name>
  <files>src/scenes/GameScene.ts</files>
  <action>
    Add player creation and input handling to GameScene:

    In GameScene.ts:
    1. Import Player from '../entities/Player'
    2. Add private property: player: Player | null = null
    3. Add private property: cursors: Phaser.Types.Input.Keyboard.CursorKeys | undefined

    4. In create() method (after map generation and rendering):
       - Find starting position: loop through map array to find first floor tile (value === 0)
       - Create player: this.player = new Player(this, startX, startY)
       - Call player.updateSpritePosition(this.gridManager) to position sprite
       - Setup keyboard input: this.cursors = this.input.keyboard?.createCursorKeys()
       - Also create WASD keys using addKeys: { W: 'W', A: 'A', S: 'S', D: 'D' }

    5. In update() method:
       - If (!this.player || !this.cursors) return
       - Check Phaser.Input.Keyboard.JustDown() for each key to prevent repeat firing:
         - Up arrow or W: player.move(0, -1, this.map)
         - Down arrow or S: player.move(0, 1, this.map)
         - Left arrow or A: player.move(-1, 0, this.map)
         - Right arrow or D: player.move(1, 0, this.map)
       - After each successful move, call player.updateSpritePosition(this.gridManager)

    AVOID: Don't add complex turn management yet. Direct input → movement is sufficient for this plan, per research guidance to "start simple."
  </action>
  <verify>TypeScript compiles, player sprite renders, input handlers registered correctly</verify>
  <done>Player spawns on valid floor tile, keyboard input moves player, movement respects walls and boundaries</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Playable dungeon crawler with grid-based player movement</what-built>
  <how-to-verify>
    1. Run: npm run dev
    2. Open browser to localhost
    3. Confirm: Green square (player) appears on a floor tile in the dungeon
    4. Test: Press arrow keys (↑↓←→) - player moves one tile at a time
    5. Test: Press WASD keys - player also moves correctly
    6. Test: Try moving into walls - player does NOT move through walls
    7. Test: Move around the dungeon - player can navigate rooms and corridors
    8. Confirm: Player stays aligned to grid (no sub-tile positioning issues)
    9. Confirm: Movement feels responsive (no lag between keypress and movement)
    10. Refresh page: New dungeon generates, player spawns in new location
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Player entity renders correctly on canvas
- [ ] Arrow keys and WASD both control player movement
- [ ] Player cannot move through walls
- [ ] Player cannot move out of bounds
- [ ] Grid alignment is maintained during movement
- [ ] Input feels responsive (uses JustDown to prevent repeat firing)
- [ ] Phase 1 complete: basic game loop functional
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Player movement works correctly with collision detection
- Foundation complete for Phase 2 (Combat & Enemies)
- Phase 1 complete - core loop established

</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-loop/01-03-SUMMARY.md`:

# Phase 1 Plan 3: Player Movement & Turn System Summary

**Player entity implemented with grid-based movement and keyboard controls - Phase 1 complete**

## Accomplishments

- Player entity created with grid position tracking separate from sprite
- Keyboard input system (arrow keys + WASD) for movement
- Collision detection preventing movement through walls
- Player spawns on valid floor tile automatically
- Core game loop complete: render dungeon → spawn player → handle input → update position

## Files Created/Modified

- `src/entities/Player.ts` - Player entity with grid-based movement
- `src/types/index.ts` - Entity interface
- `src/scenes/GameScene.ts` - Player creation, input handling, update loop

## Decisions Made

- Used green tint (0x00ff00) for player visibility (placeholder until sprites added)
- Player sprite 28x28 pixels (slightly smaller than 32x32 tile for visual clarity)
- Supported both arrow keys and WASD for accessibility
- Used JustDown for input to prevent key repeat issues
- Simple direct input → movement (no action queue or turn manager yet, as per research)

## Issues Encountered

[Document any issues, or state "None"]

## Next Phase Readiness

**Phase 1 Complete** - Foundation established:
- ✅ Game framework running (Phaser 3 + Rot.js)
- ✅ Grid coordinate system functional
- ✅ Procedural dungeon generation working
- ✅ Player movement with collision detection

Ready for Phase 2: Combat & Enemies
- Player entity exists for combat system to reference
- Grid system ready for enemy positioning
- Map structure supports entity placement

## Next Step

Phase 1 complete. Ready for Phase 2 planning.

</output>
