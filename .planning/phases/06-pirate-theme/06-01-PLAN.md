# Plan 06-01: Core Pirate Systems Foundation

## Objective
Establish the foundational systems for the pirate roguelite: Insight, Curse, and updated type definitions. These systems will be used by all subsequent features.

## Prerequisites
- Existing MetaProgressionManager
- Existing types/index.ts
- Working game loop

## Tasks

### 1. Update Type Definitions
**File: `src/types/index.ts`**

Add new enums and interfaces:

```typescript
// --- Pirate Theme Types ---

// Ship factions (replace RoomTheme for ship combat)
export enum ShipFaction {
  GILDED_ARMADA,    // Pale Messenger influenced (unknowingly)
  DROWNED_FLEET,    // Drowned Sovereign servants
  FREE_CAPTAIN,     // Independent pirates
  MONASTERY         // Neutral truth-seekers
}

// Pirate character classes
export enum PirateClass {
  DUELIST,          // Combat focus - high damage, low defense
  QUARTERMASTER,    // Trade focus - buffs, economy bonuses
  NAVIGATOR,        // Exploration focus - reveal secrets, mobility
  CHAPLAIN          // Knowledge focus - rituals, insight bonuses
}

// Insight thresholds
export enum InsightThreshold {
  IGNORANCE = 0,      // 0-29
  SUSPICION = 30,     // 30-49
  UNDERSTANDING = 50, // 50-69
  TRUE_SIGHT = 70,    // 70-89
  TRANSCENDENCE = 90  // 90-100
}

// Curse manifestation types (based on playstyle)
export enum CurseManifestation {
  COMBAT,       // Combat-heavy players
  TRADE,        // Trade-focused players
  EXPLORATION,  // Exploration-focused players
  BALANCED      // Mixed playstyle
}

// Curse stages (1-5)
export interface CurseState {
  stage: number;           // 1-5
  manifestation: CurseManifestation;
  daysRemaining: number;   // Until blood moon
  playstyleScores: {
    combat: number;
    trade: number;
    exploration: number;
  };
}

// Insight state
export interface InsightState {
  current: number;         // 0-100
  history: InsightEvent[];
}

export interface InsightEvent {
  source: string;          // What caused the gain
  amount: number;
  timestamp: number;
}

// Paranoia state (unlocks after Pale Messenger discovery)
export interface ParanoiaState {
  current: number;         // 0-100
  discovered: boolean;     // Has player discovered Pale Messenger?
  floor: number;           // Minimum paranoia (20 after discovery)
}

// Pale Attention state (profile-level persistence)
export interface PaleAttentionState {
  current: number;         // 0-100
  floor: number;           // Permanent minimum (locks at thresholds)
  lastThresholdCrossed: number;
}

// Extended save data for pirate theme
export interface PirateSaveData {
  // Character-level (reset on death)
  insight: InsightState;
  curse: CurseState;
  paranoia: ParanoiaState;
  statuePieces: string[];        // IDs of collected pieces
  bindingWords: string[];        // IDs of learned words
  
  // Profile-level (persists across deaths)
  paleAttention: PaleAttentionState;
  loreDiscovered: string[];      // IDs of texts read
  translationProgress: Record<string, number>;
  awarenessThresholdCrossed: boolean;  // Discovered Pale Messenger?
}
```

### 2. Create Insight System
**File: `src/systems/InsightSystem.ts`**

```typescript
import { InsightState, InsightThreshold, InsightEvent } from '../types';

export class InsightSystem {
  private state: InsightState;
  private thresholdCallbacks: Map<InsightThreshold, (() => void)[]>;
  
  constructor(initialInsight: number = 0) {
    this.state = {
      current: Math.max(0, Math.min(100, initialInsight)),
      history: []
    };
    this.thresholdCallbacks = new Map();
  }
  
  // Get current insight level
  getCurrent(): number {
    return this.state.current;
  }
  
  // Get threshold level name
  getThresholdLevel(): string {
    if (this.state.current >= 90) return 'TRANSCENDENCE';
    if (this.state.current >= 70) return 'TRUE_SIGHT';
    if (this.state.current >= 50) return 'UNDERSTANDING';
    if (this.state.current >= 30) return 'SUSPICION';
    return 'IGNORANCE';
  }
  
  // Check if insight meets threshold
  meetsThreshold(threshold: InsightThreshold): boolean {
    return this.state.current >= threshold;
  }
  
  // Gain insight
  gain(amount: number, source: string): number {
    const oldInsight = this.state.current;
    this.state.current = Math.min(100, this.state.current + amount);
    
    // Record event
    this.state.history.push({
      source,
      amount,
      timestamp: Date.now()
    });
    
    // Check threshold crossings
    this.checkThresholds(oldInsight, this.state.current);
    
    return this.state.current;
  }
  
  // Lose insight (rare - memory wipe, denial)
  lose(amount: number, source: string): number {
    const oldInsight = this.state.current;
    this.state.current = Math.max(0, this.state.current - amount);
    
    this.state.history.push({
      source: `LOSS: ${source}`,
      amount: -amount,
      timestamp: Date.now()
    });
    
    return this.state.current;
  }
  
  // Register callback for threshold crossing
  onThreshold(threshold: InsightThreshold, callback: () => void): void {
    if (!this.thresholdCallbacks.has(threshold)) {
      this.thresholdCallbacks.set(threshold, []);
    }
    this.thresholdCallbacks.get(threshold)!.push(callback);
  }
  
  // Check and trigger threshold callbacks
  private checkThresholds(oldValue: number, newValue: number): void {
    const thresholds = [
      InsightThreshold.SUSPICION,
      InsightThreshold.UNDERSTANDING,
      InsightThreshold.TRUE_SIGHT,
      InsightThreshold.TRANSCENDENCE
    ];
    
    for (const threshold of thresholds) {
      if (oldValue < threshold && newValue >= threshold) {
        const callbacks = this.thresholdCallbacks.get(threshold) || [];
        callbacks.forEach(cb => cb());
      }
    }
  }
  
  // Serialize for save
  serialize(): InsightState {
    return { ...this.state };
  }
  
  // Load from save
  static deserialize(data: InsightState): InsightSystem {
    const system = new InsightSystem(data.current);
    system.state.history = [...data.history];
    return system;
  }
}
```

### 3. Create Curse System
**File: `src/systems/CurseSystem.ts`**

```typescript
import { CurseState, CurseManifestation } from '../types';

export interface CurseEffects {
  attackModifier: number;
  defenseModifier: number;
  priceModifier: number;      // Trading prices
  crewMoraleModifier: number;
  insightGainModifier: number;
  visibilityModifier: number; // How scary you look to NPCs
}

export class CurseSystem {
  private state: CurseState;
  private stageCallbacks: Map<number, (() => void)[]>;
  
  constructor(daysUntilBloodMoon: number = 30) {
    this.state = {
      stage: 1,
      manifestation: CurseManifestation.BALANCED,
      daysRemaining: daysUntilBloodMoon,
      playstyleScores: {
        combat: 0,
        trade: 0,
        exploration: 0
      }
    };
    this.stageCallbacks = new Map();
  }
  
  // Get current stage (1-5)
  getStage(): number {
    return this.state.stage;
  }
  
  // Get manifestation type
  getManifestation(): CurseManifestation {
    return this.state.manifestation;
  }
  
  // Get days remaining
  getDaysRemaining(): number {
    return this.state.daysRemaining;
  }
  
  // Advance a day
  advanceDay(): void {
    this.state.daysRemaining = Math.max(0, this.state.daysRemaining - 1);
    
    // Auto-advance stage based on time
    if (this.state.daysRemaining <= 6 && this.state.stage < 5) {
      this.setStage(5);
    } else if (this.state.daysRemaining <= 12 && this.state.stage < 4) {
      this.setStage(4);
    } else if (this.state.daysRemaining <= 18 && this.state.stage < 3) {
      this.setStage(3);
    } else if (this.state.daysRemaining <= 24 && this.state.stage < 2) {
      this.setStage(2);
    }
  }
  
  // Record playstyle action
  recordAction(type: 'combat' | 'trade' | 'exploration', weight: number = 1): void {
    this.state.playstyleScores[type] += weight;
    this.updateManifestation();
  }
  
  // Update manifestation based on playstyle
  private updateManifestation(): void {
    const { combat, trade, exploration } = this.state.playstyleScores;
    const total = combat + trade + exploration;
    
    if (total < 10) {
      this.state.manifestation = CurseManifestation.BALANCED;
      return;
    }
    
    const combatRatio = combat / total;
    const tradeRatio = trade / total;
    const explorationRatio = exploration / total;
    
    if (combatRatio > 0.5) {
      this.state.manifestation = CurseManifestation.COMBAT;
    } else if (tradeRatio > 0.5) {
      this.state.manifestation = CurseManifestation.TRADE;
    } else if (explorationRatio > 0.5) {
      this.state.manifestation = CurseManifestation.EXPLORATION;
    } else {
      this.state.manifestation = CurseManifestation.BALANCED;
    }
  }
  
  // Manually set stage (for events, insight discoveries)
  setStage(stage: number): void {
    const newStage = Math.max(1, Math.min(5, stage));
    if (newStage > this.state.stage) {
      const oldStage = this.state.stage;
      this.state.stage = newStage;
      
      // Trigger callbacks for each stage crossed
      for (let s = oldStage + 1; s <= newStage; s++) {
        const callbacks = this.stageCallbacks.get(s) || [];
        callbacks.forEach(cb => cb());
      }
    }
  }
  
  // Register callback for stage change
  onStage(stage: number, callback: () => void): void {
    if (!this.stageCallbacks.has(stage)) {
      this.stageCallbacks.set(stage, []);
    }
    this.stageCallbacks.get(stage)!.push(callback);
  }
  
  // Get current effects based on stage and manifestation
  getEffects(): CurseEffects {
    const stage = this.state.stage;
    const manifestation = this.state.manifestation;
    
    // Base effects by stage
    const baseEffects: CurseEffects = {
      attackModifier: 0,
      defenseModifier: 0,
      priceModifier: 0,
      crewMoraleModifier: 0,
      insightGainModifier: 0,
      visibilityModifier: stage * 0.1  // NPCs notice you more
    };
    
    // Modify based on manifestation
    switch (manifestation) {
      case CurseManifestation.COMBAT:
        baseEffects.attackModifier = stage * 0.05;  // +5% per stage
        baseEffects.priceModifier = stage * 0.05;   // +5% prices (feared)
        baseEffects.crewMoraleModifier = -stage * 2;
        break;
        
      case CurseManifestation.TRADE:
        baseEffects.priceModifier = -stage * 0.03;  // -3% prices (compulsion)
        baseEffects.crewMoraleModifier = -stage * 3; // Trust erodes
        break;
        
      case CurseManifestation.EXPLORATION:
        baseEffects.insightGainModifier = stage * 0.1;  // +10% insight gain
        baseEffects.defenseModifier = -stage * 0.03;    // Fragile
        break;
        
      case CurseManifestation.BALANCED:
        // Mild everything
        baseEffects.attackModifier = stage * 0.02;
        baseEffects.priceModifier = stage * 0.02;
        baseEffects.crewMoraleModifier = -stage;
        break;
    }
    
    return baseEffects;
  }
  
  // Check if curse is critical (stage 5)
  isCritical(): boolean {
    return this.state.stage >= 5;
  }
  
  // Check if blood moon has arrived
  isBloodMoon(): boolean {
    return this.state.daysRemaining <= 0;
  }
  
  // Serialize for save
  serialize(): CurseState {
    return { ...this.state };
  }
  
  // Load from save
  static deserialize(data: CurseState): CurseSystem {
    const system = new CurseSystem(data.daysRemaining);
    system.state = { ...data };
    return system;
  }
}
```

### 4. Create Pirate Class Definitions
**File: `src/systems/PirateClassSystem.ts`**

```typescript
import { PirateClass, CombatStats } from '../types';

export interface PirateClassDefinition {
  id: PirateClass;
  name: string;
  description: string;
  color: number;  // Sprite tint
  baseStats: CombatStats;
  specialAbility: string;
  insightBonus: number;      // Starting insight modifier
  curseResistance: number;   // Slows curse progression
}

export const PIRATE_CLASSES: Record<PirateClass, PirateClassDefinition> = {
  [PirateClass.DUELIST]: {
    id: PirateClass.DUELIST,
    name: 'Duelist',
    description: 'A blade-master who strikes fast and hard. High damage, low defense.',
    color: 0xff4444,  // Red
    baseStats: { maxHP: 18, currentHP: 18, attack: 7, defense: 1 },
    specialAbility: 'Riposte - Counter-attack when hit',
    insightBonus: 0,
    curseResistance: 0
  },
  
  [PirateClass.QUARTERMASTER]: {
    id: PirateClass.QUARTERMASTER,
    name: 'Quartermaster',
    description: 'Master of supplies and crew. Buffs allies, controls economy.',
    color: 0xffaa00,  // Gold
    baseStats: { maxHP: 20, currentHP: 20, attack: 4, defense: 3 },
    specialAbility: 'Rally - Boost crew morale and stats',
    insightBonus: 0,
    curseResistance: 0.1  // 10% slower curse
  },
  
  [PirateClass.NAVIGATOR]: {
    id: PirateClass.NAVIGATOR,
    name: 'Navigator',
    description: 'Sees paths others miss. High mobility, reveals secrets.',
    color: 0x00aaff,  // Blue
    baseStats: { maxHP: 16, currentHP: 16, attack: 4, defense: 2 },
    specialAbility: 'Phase - Move through obstacles once per combat',
    insightBonus: 10,  // Start with +10 insight
    curseResistance: 0
  },
  
  [PirateClass.CHAPLAIN]: {
    id: PirateClass.CHAPLAIN,
    name: 'Chaplain',
    description: 'Scholar of forbidden knowledge. Rituals and insight mastery.',
    color: 0xaa44ff,  // Purple
    baseStats: { maxHP: 14, currentHP: 14, attack: 3, defense: 2 },
    specialAbility: 'Dispel - Remove status effects, sense thralls',
    insightBonus: 20,  // Start with +20 insight
    curseResistance: -0.2  // 20% FASTER curse (knowledge has cost)
  }
};

export function getPirateClassStats(pirateClass: PirateClass, upgrades: Record<string, number>): CombatStats {
  const definition = PIRATE_CLASSES[pirateClass];
  const base = definition.baseStats;
  
  return {
    maxHP: base.maxHP + (upgrades['MAX_HP'] || 0) * 2,
    currentHP: base.maxHP + (upgrades['MAX_HP'] || 0) * 2,
    attack: base.attack + (upgrades['ATTACK'] || 0),
    defense: base.defense + (upgrades['DEFENSE'] || 0)
  };
}
```

### 5. Update MetaProgressionManager
**File: `src/systems/MetaProgressionManager.ts`**

Add pirate-specific persistence:

```typescript
// Add to MetaSaveData interface or create extended version
export interface PirateMetaSaveData extends MetaSaveData {
  // Profile-level (persists forever)
  paleAttention: {
    current: number;
    floor: number;
  };
  awarenessThresholdCrossed: boolean;
  loreDiscovered: string[];
}

// Add methods to MetaProgressionManager:

// Pale Attention (profile-level)
getPaleAttention(): number {
  return this.save.paleAttention?.current ?? 0;
}

getPaleAttentionFloor(): number {
  return this.save.paleAttention?.floor ?? 0;
}

addPaleAttention(amount: number): void {
  if (!this.save.paleAttention) {
    this.save.paleAttention = { current: 0, floor: 0 };
  }
  
  const oldValue = this.save.paleAttention.current;
  this.save.paleAttention.current = Math.min(100, oldValue + amount);
  
  // Lock floor at thresholds
  const thresholds = [20, 40, 60, 80, 100];
  for (const threshold of thresholds) {
    if (this.save.paleAttention.current >= threshold && 
        this.save.paleAttention.floor < threshold) {
      this.save.paleAttention.floor = threshold;
    }
  }
  
  this.saveNow();
}

// Can never go below floor
reducePaleAttention(amount: number): void {
  if (!this.save.paleAttention) return;
  
  const floor = this.save.paleAttention.floor;
  this.save.paleAttention.current = Math.max(
    floor,
    this.save.paleAttention.current - amount
  );
  this.saveNow();
}

// Awareness threshold (discovering Pale Messenger)
hasDiscoveredPaleMessenger(): boolean {
  return this.save.awarenessThresholdCrossed ?? false;
}

markPaleMessengerDiscovered(): void {
  this.save.awarenessThresholdCrossed = true;
  // Immediately lock attention floor at 20
  if (!this.save.paleAttention || this.save.paleAttention.floor < 20) {
    this.save.paleAttention = {
      current: Math.max(this.save.paleAttention?.current ?? 0, 20),
      floor: 20
    };
  }
  this.saveNow();
}

// Lore discovery tracking
hasDiscoveredLore(loreId: string): boolean {
  return (this.save.loreDiscovered ?? []).includes(loreId);
}

discoverLore(loreId: string): void {
  if (!this.save.loreDiscovered) {
    this.save.loreDiscovered = [];
  }
  if (!this.save.loreDiscovered.includes(loreId)) {
    this.save.loreDiscovered.push(loreId);
    this.saveNow();
  }
}
```

### 6. Create Session State Manager
**File: `src/systems/SessionStateManager.ts`**

Manages per-run state (resets on death):

```typescript
import { InsightSystem } from './InsightSystem';
import { CurseSystem } from './CurseSystem';
import { PirateClass, CurseManifestation } from '../types';
import { PIRATE_CLASSES } from './PirateClassSystem';

export interface SessionState {
  insight: InsightSystem;
  curse: CurseSystem;
  pirateClass: PirateClass;
  currentDay: number;
  statuePieces: string[];
  bindingWords: string[];
}

export class SessionStateManager {
  private static instance: SessionStateManager | null = null;
  
  private insight: InsightSystem;
  private curse: CurseSystem;
  private pirateClass: PirateClass;
  private currentDay: number;
  private statuePieces: string[];
  private bindingWords: string[];
  
  private constructor() {
    this.pirateClass = PirateClass.DUELIST;
    this.insight = new InsightSystem(0);
    this.curse = new CurseSystem(30);
    this.currentDay = 1;
    this.statuePieces = [];
    this.bindingWords = [];
  }
  
  static getInstance(): SessionStateManager {
    if (!SessionStateManager.instance) {
      SessionStateManager.instance = new SessionStateManager();
    }
    return SessionStateManager.instance;
  }
  
  // Start new run
  startNewRun(pirateClass: PirateClass): void {
    const classDefinition = PIRATE_CLASSES[pirateClass];
    
    this.pirateClass = pirateClass;
    this.insight = new InsightSystem(classDefinition.insightBonus);
    this.curse = new CurseSystem(30);
    this.currentDay = 1;
    this.statuePieces = [];
    this.bindingWords = [];
  }
  
  // Getters
  getInsight(): InsightSystem { return this.insight; }
  getCurse(): CurseSystem { return this.curse; }
  getPirateClass(): PirateClass { return this.pirateClass; }
  getCurrentDay(): number { return this.currentDay; }
  getStatuePieces(): string[] { return [...this.statuePieces]; }
  getBindingWords(): string[] { return [...this.bindingWords]; }
  
  // Day advancement
  advanceDay(): void {
    this.currentDay++;
    this.curse.advanceDay();
  }
  
  // Statue pieces
  collectStatuePiece(pieceId: string): void {
    if (!this.statuePieces.includes(pieceId)) {
      this.statuePieces.push(pieceId);
    }
  }
  
  // Binding words
  learnBindingWord(wordId: string): void {
    if (!this.bindingWords.includes(wordId)) {
      this.bindingWords.push(wordId);
    }
  }
  
  // Check win conditions
  hasAllStatuePieces(): boolean {
    return this.statuePieces.length >= 5;  // Assuming 5 pieces
  }
  
  hasAllBindingWords(): boolean {
    return this.bindingWords.length >= 3;  // 3 words required
  }
  
  canPerformSeverance(): boolean {
    return this.hasAllStatuePieces() && 
           this.hasAllBindingWords() &&
           this.insight.getCurrent() >= 70;
  }
}
```

## Verification

1. **Type Check**: Run `npm run build` - should compile without errors
2. **Insight System**: 
   - Create instance, gain insight, verify threshold callbacks fire
   - Test serialization/deserialization
3. **Curse System**:
   - Create instance, advance days, verify stage progression
   - Record actions, verify manifestation changes
   - Test effects calculation
4. **Session State**:
   - Start new run, verify class bonuses apply
   - Test day advancement, piece collection

## Files Changed
- `src/types/index.ts` - New pirate types
- `src/systems/InsightSystem.ts` - NEW
- `src/systems/CurseSystem.ts` - NEW  
- `src/systems/PirateClassSystem.ts` - NEW
- `src/systems/SessionStateManager.ts` - NEW
- `src/systems/MetaProgressionManager.ts` - Add pirate persistence

## Next Steps
After this plan, proceed to 06-02 (Ship Layout System) to create the multi-level ship dungeons with insight-based revelation.
